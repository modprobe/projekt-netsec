\documentclass[a4paper,12bpt]{scrartcl}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[ngerman]{babel}
\usepackage[shortlabels]{enumitem}
\usepackage{listings}
\usepackage{xcolor}
\usepackage[title]{appendix}
\usepackage[left=2cm,right=2cm,top=2cm,bottom=3cm]{geometry}
\usepackage{graphicx}
\usepackage[hidelinks]{hyperref}

\newcommand*{\Comment}[1]{\hfill\makebox[8.0cm][l]{#1}}%
\lstdefinestyle{BashInputStyle}{
  language=bash,
  basicstyle=\small\sffamily,
  numbers=left,
  numberstyle=\tiny,
  numbersep=6pt,
  frame=tb,
  columns=fullflexible,
  backgroundcolor=\color{yellow!20},
  linewidth=\linewidth,
  xleftmargin=5mm,
  framexleftmargin=5mm,
  escapechar=\&% char to escape out of listings and back to LaTeX
}
\lstset{style=BashInputStyle}

\lstnewenvironment{rootcommands}[1][]{%
  \renewcommand{\thelstnumber}{\#}
  \lstset{style=BashInputStyle,#1}%
}{%
}

\lstnewenvironment{usercommands}[1][]{%
  \renewcommand{\thelstnumber}{\$}
  \lstset{style=BashInputStyle,#1}%
}{%
}

\renewcommand*{\thesection}{Aufgabe~\arabic{section}:}

\author{Patrick Eickhoff, Alexander Timmermann}
\title{Labreport \#6}
\date{}

\def\labelitemi{\textbf{--}}

\begin{document}
\maketitle
\section{Absicherung des TCP-Chats mit SSL}
\label{sec:tcp_chat}
Um unseren ursprünglichen TCP-Chat mit SSL zu sichern, bedienen wir uns des \textit{javax.net.ssl}
Packetes. Dieses beinhaltet SSLSockets und SSLServerSockets, die wir benutzen um, eine sichere
Verbindung aufzubauen. Die Sockets werden mittels SSLSocketFactory erstellt.
Alle SSLSockets greifen können auf einen \textit{keyStore} und einen \textit{trustStore} zugreifen.
Diese Java-spezifischen Datenbanken beinhalten Zertifikate und private Schlüssel für den Aufbau der
SSL-Verbindung. Der \textit{keyStore}  beinhaltet einen privaten Schlüssel und die Zertifikate, die
beim SSL-Handshake mitgeschickt werden. Im \textit{trustStore} sind, dann die Zertifikate gespeichert,
denen vertraut wird (trusted Certificate). Den \textit{keyStore} des Clienten, haben wir
mit \textit{keytool} wie folgt initiiert:\\
\texttt{keytool -keystore clienttest.keystore -keyalg RSA -genkey -alias client.}\\
Dieser Befehl erzeugt ein neues Schlüsselpaar mittels RSA, sowie ein Zertifikat mit dem Alias
"client". Beim Erzeugen des Zertifikats fragt uns \textit{keytool} nach den üblichen Parametern,
wie z.B. Name, Länderkürzel, Organisation, etc. . Für unsere Anwendung ist nur wichtig, dass
der Client einen Namen in sein Zertifikat einträgt. Für den Server erstellen wir respektive
einen \textit{keyStore}:\\
\texttt{keytool -keystore servertest.keystore -keyalg RSA -genkey -alias server.}\\
Beim SSlHandshake werden die Zertifikate aus den Keystores dem Verbindungspartner präsentiert.
Also präsentiert z.B. der Client sein selbstsigniertes Zertifikat aus \textit{clienttest.keystore}
dem Server. Der Server präsentiert wiederum sein Zertifikat dem Client.
Die präsentierten Zertifikate werden dann gegen die Zertifikate im \textit{trustStore}
abgeglichen. Also müsssen wir die Zertifikate jeweils in die \textit{trustStores} des
Verbindungspartners importieren:
\begin{usercommands}
  keytool -importkeystore -srckeystore servertest.keystore -destkeystore clienttest.truststore
  keytool -importkeystore -srckeystore clienttest.keystore -destkeystore servertest.truststore
\end{usercommands}
Jetzt akzeptieren Server und Client die präsentierten Zertifikate und eine sichere SSLVerbidung
wird aufgebaut.\\\\
Nun wollten wir unsere Nutzername-Password-Authentifikation durch die Zertifikatsauthentifikation
der SSL-Verbindung ersetzen. Wie zuvor erwähnt, muss jedes Clienten-Zertifikat mindestens einen
Namen enthalten. So können wir ein vertrautes Zertifikat genau einem Nutzer zuordnen.
Der Anzeige-Name im Chat ist dann dem Namen im Zertifikat identisch.\\\\
Bei der vorherigen Implementation unseres Chats konnte man sich einfach mittels \textit{netcat}
verbinden. Deshalb war kein Java-Client von Nöten. Da \textit{netcat} aber kein SSL-Protokol
unterstützt, benötigt man zur Kommunikation nun einen Java-Chat-Clienten. Für die Implementation
siehe \ref{sec:TCP-Chat}.

\section{CAs und Webserver-Zertifikate}
\label{sec:certs}

\begin{enumerate}
    \item[\bfseries 2.]
        Um ein selbstsigniertes Zertifikat zu erzeugen, sind im wesentlichen drei
        OpenSSL-Befehle notwendig:

        \begin{usercommands}
openssl genrsa -out server.key 2048
openssl req -new -key server.key -out server.csr
openssl x509 -req -days 365 -in server.csr -signkey server.key -out server.crt
        \end{usercommands}

        Mit dem ersten Befehl erzeugen wir einen neuen, 2048-bit langen privaten
        Schlüssel. Wir erstellen dann mit dem zweiten Befehl die sog.
        \textit{certificate signing request}, in der die Informationen enthalten
        sind, die das Zertifikat später umfassen soll. Diese werden interaktiv
        abgefragt. Als Common Name verwenden wir \texttt{vmsrv11.svslab}.

        Im dritten Befehl verwenden wir schließlich den erstellten Private Key,
        um aus der CSR ein Zertifikat zu generieren, das 365 Tage gültig ist.

        Um dieses Zertifikat für den Apache-Server einzusetzen, ersetzen wir in
        der Konfigurationsdatei die Pfade hinter \texttt{SSLCertificateFile} und
        \texttt{SSLCertificateKeyFile} mit den Pfaden zum Zertifikat und dem
        private key.

        Dass selbst-signierte Zertifikate als unsicher angesehen werden liegt auf
        der Hand. Jeder kann sich ein Zertifikat erstellen, was bspw. für google.com
        gültig ist. Würde diesen Zertifikaten vertraut, ließe sich eine Man-in-the-Middle-Attacke
        zu google.com sehr leicht implementieren, da der User keinen Unterschied
        bemerkt, und ihm durch das Zertifikat weitere Sicherheit suggeriert wird.

        Die Aufgabe einer CA ist es, diese Angaben zu validieren und im Zweifelsfall
        die Ausstellung eines Zertifikats zu verweigern. CAs sind deshalb Firmen
        oder Organisationen, denen vertraut wird, diese Macht nicht zu missbrauchen.

    \item[\bfseries 3.]
        Um mit Hilfe von \textit{mod\_rewrite} eine Weiterleitung zu HTTPS zu
        realisieren, fügen wir folgende Optionen in die Apache-Config ein:%
        \footnote{Quelle: \url{https://wiki.apache.org/httpd/RewriteHTTPToHTTPS}}

        \begin{lstlisting}
RewriteEngine On
RewriteCond %{HTTPS} !=on
RewriteRule ^/?(.*) https://%{SERVER_NAME}/$1 [R,L]
        \end{lstlisting}

        Mit dem ersten Befehl wird die Bearbeitung der Rewrite-Regeln eingeschaltet.
        Danach wird geprüft, ob nicht bereits HTTPS verwendet wird, da damit die
        Weiterleitung hinfällig wird. Schließlich wird die Rewrite-Regel definiert,
        die dann weiterleitet. Die Optionen am Ende sind die Flags. \texttt{L}
        gibt an, dass die Regel die letzte ist, die ausgeführt wird. \texttt{R}
        spezifiziert, dass ein HTTP Redirect passieren soll.

        Die Regel selbst ist ein regulärer Ausdruck, bei dem alles nach einem
        optionalen ``\texttt{/}'' matched und in die HTTPS-URL eingesetzt wird.

    \item[\bfseries 4.]
        Über die verschlüsselte Verbindung können wir die Zugangsdaten
        selbstverständlich nicht mitlesen. Verwenden wir \textit{sslstrip} als
        Proxy, so wird die Umleitung auf die verschlüsselte Verbindung verhindert
        und wir können die Zugangsdaten recht komfortabel im Log-File nachlesen.

        Die Sicherheit der Weiterleitung ist damit maximal als ``gut gemeinte''
        Maßnahme für Endanwender gedacht, taugt aber nicht, ernsthafte Angriffe
        abzuwehren. Hierzu sind weitere Maßnahmen nötig, wie beispielsweise HSTS.

        \textit{HTTP Strict Transport Security (HSTS)} ist ein in RFC 6797%
        \footnote{\url{https://tools.ietf.org/html/rfc6797}} beschriebener
        Standard, der einen solchen Angriff verhindern kann. Wird HSTS aktiviert,
        so können Seiten unter einer Domain, die HSTS setzt, nicht über eine
        unverschlüsselte Verbindung abgerufen weden.
        HSTS wird über einen Header aktiviert, der bei der Antwort mitgesendet
        wird und etwa so aussieht:

        \begin{lstlisting}
Strict-Transport-Security: max-age=15768000
        \end{lstlisting}

        Damit wird HSTS im Browser strikt forciert und lässt sich auch für
        den Endnutzer nicht wieder abschalten.
        Mit dem \texttt{max-age}-Parameter wird eine Art ``Haltbarkeitsdatum''
        in Sekunden angegeben. 15768000 Sekunden entsprechen etwa einem halben
        Jahr, danach wird der Browser eine unverschlüsselte Verbindung prinzipiell
        wieder erlauben, wenn nicht erneut ein HSTS-Header mitgesendet wird.
\end{enumerate}

\section{Unsichere selbstentwickelte Verschlüsselungsalgorithmen}
\label{sec:crypto}

\begin{appendices}
  \section{TCP-Chat}
  \label{sec:TCP-Chat}
  \lstinputlisting[caption=ChatServer.java,language=java]{java_ssl_tcp_chat/tcp_chat/ChatServer.java}
  \lstinputlisting[caption=ChatClient.java,language=java]{java_ssl_tcp_chat/tcp_chat/ChatClient.java}
  \lstinputlisting[caption=ClientThread.java,language=java]{java_ssl_tcp_chat/tcp_chat/ClientThread.java}
\end{appendices}
\end{document}
